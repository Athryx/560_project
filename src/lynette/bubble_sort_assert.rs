use vstd :: prelude :: * ; use vstd :: relations :: sorted_by ; fn sorted (arr : Seq < i32 >) -> bool { forall | i1 : int , i2 : int | 0 <= i1 < i2 < arr . len () ==> arr [i1] <= arr [i2] } fn bubble_sort (arr : & mut Vec < i32 >) { let n = arr . len () ; let mut i = 0 ; while i < n { assert ! (! (true) || ((((0 <= i <= n) && (arr . len () == n)) && (forall | i1 : int , i2 : int | ((n - i - 1) < i1 < i2 < n) ==> arr [i1] <= arr [i2])) && (forall | i1 : int , i2 : int | (0 <= i1 < (n - i) <= i2 < n) ==> arr [i1] <= arr [i2]))) let mut swapped = false ; let mut j = 0 ; while j < (n - i - 1) invariant 0 <= j <= (n - i - 1) , arr . len () == n , forall | elem : int | 0 <= elem < j ==> arr [elem] <= arr [j as int] , forall | i1 : int , i2 : int | ((n - i - 1) < i1 < i2 < n) ==> arr [i1] <= arr [i2] , forall | i1 : int , i2 : int | (0 <= i1 < (n - i) <= i2 < n) ==> arr [i1] <= arr [i2] , ! swapped ==> forall | i1 : int , i2 : int | 0 <= i1 < i2 <= j ==> arr [i1] <= arr [i2] , { if arr [j] > arr [j + 1] { let tmp = arr [j] ; arr [j] = arr [j + 1] ; arr [j + 1] = tmp ; swapped = true ; } j += 1 ; } if ! swapped { i = n ; break ; } i += 1 ; assert ! (! (true) || ((((0 <= i <= n) && (arr . len () == n)) && (forall | i1 : int , i2 : int | ((n - i - 1) < i1 < i2 < n) ==> arr [i1] <= arr [i2])) && (forall | i1 : int , i2 : int | (0 <= i1 < (n - i) <= i2 < n) ==> arr [i1] <= arr [i2]))) } assert ! (! (true) || (sorted (arr . view ()))) }